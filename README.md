Connect Four
============

The user uses the program by first being prompted to select her opponent. Inputting 1 selects a human opponent, while inputting 2 selects a computer opponent. After, the user is prompted during her turn to choose which column to put her next piece in. After selecting this, the piece is placed in the column, and the user must wait for the second player (another user, or a computer) to take its turn. This continues until the user wins or loses, since the here the program will display the winning player and end.

The program works internally through two classes. The first class, C4Col, manages a single column. This class constructs an empty column, and then can check whether the column is full, return the contents of a specific slot, return the maximum number of discs possible in the column, add a new disc, or return the number of discs currently in the column. The slots in the column are initialized to spaces in the constructor. With each call to addDisc for a specific column, a new disc is added to the column. The isFull() method is used to notify the user if the column is completely full and another disc cannot be added. The second class, C4Board, initializes a C4Col object to represent each column of the board. The display member function prints out the current board. The play member function is where most the gameplay occurs. This gameplay occurs in a while loop, which only breaks when the user inputs a -1 or when a winner is determined. At the beginning of each turn (each iteration through the while loop), the board is displayed through a call to display(). The player is prompted for a move, and based on the row chosen, addDisc(char) from the C4Col class is called on the chosen C4Col object. The character inserted through addDisc is determined based on whether it is Player 1 or 2's turn. The check private member function is called after to see if there are four of same pieces in a row anywhere on the board (meaning a player has won). If the check function returned 1 (meaning a player had won), a winner was declared, and the while loop was broken. If nobody had won yet, the turn counter would be incremented and the while loop would continue.

I implemented my approach to the extra credit by first giving the user an option of a human or computer opponent immediately upon launching the program. If the computer opponent was selected, Player 2 would be operated by the computer. This computer opponent would simply place a piece at a random row based on a random number generator. After the random number was generated, I used usleep to slow the game down, as otherwise the computers move would be a little too immediate. The computer opponent continues to play the game until it wins or loses.

The main file simply asks the user for a choice of a human or computer opponent, and calls the play member function of C4Board on a C4Board object.

The program was verified through many tests of the program. In particular, I tested the program with a variety of incorrect inputs to ensure the program could handle these situations with grace. For example, if when the user is prompted to pick his opponent, he enters a number other than 1 or 2, he will be prompted once again to pick one until he enters a valid choice. Further, if the C4Col member function getDisc is called with an invalid disc input, an error message is displayed. This also occurs if the user selects a row that is already full, and in this case, the user's turn is also skipped to discourage careless playing. I also played the game many times to ensure the check mechanism worked as expected.

Deconstructors are needed with dynamic memory management because otherwise the memory allocated will never be freed. Under these conditions, the system can eventually run out of memory, which would lead to a memory leak. A deconstructor, meanwhile, solves this problem by freeing up this memory once it becomes unnecessary.
